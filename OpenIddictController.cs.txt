using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Primitives;
using Microsoft.IdentityModel.Tokens;
using OpenIddict.Abstractions;
using OpenIddict.Server.AspNetCore;
using static OpenIddict.Abstractions.OpenIddictConstants;
using System.Collections.Immutable;
using System.Security.Claims;
using Microsoft.Extensions.Localization;
using OpenIdDictMvcSvr.Localizers;
using OpenIdDictMvcSvr.Data;
using OpenIdDictMvcSvr.Dto;
using OpenIdDictMvcSvr.ActionAttributes;
using static OpenIddict.Abstractions.OpenIddictConstants.Permissions;
using static System.Net.Mime.MediaTypeNames;
using Org.BouncyCastle.Asn1.Ocsp;
using System.Net;
using System.Security;
using static System.Formats.Asn1.AsnWriter;


namespace OpenIdDictMvcSvr.Controllers
{
    public class OpenIddictController : Controller
    {
        private readonly IOpenIddictApplicationManager _applicationManager;
        private readonly IOpenIddictAuthorizationManager _authorizationManager;
        private readonly IOpenIddictScopeManager _scopeManager;
        private readonly SignInManager<OidcIdentityUser> _signInManager;
        private readonly UserManager<OidcIdentityUser> _userManager;
        private readonly RoleManager<IdentityRole> _roleManager;
        private readonly IConfiguration _configuration;
        private readonly IStringLocalizer<OpenIddictLocalizerResource> _sharedLocalizer;
        private readonly string _claimprefixval = "";
        private readonly string _roleprefixval = "";

        public OpenIddictController(
            IOpenIddictApplicationManager applicationManager,
            IOpenIddictAuthorizationManager authorizationManager,
            IOpenIddictScopeManager scopeManager,
            SignInManager<OidcIdentityUser> signInManager,
            UserManager<OidcIdentityUser> userManager,
            RoleManager<IdentityRole> roleManager,
            IConfiguration configuration,
            IStringLocalizer<OpenIddictLocalizerResource> sharedLocalizer)
        {
            _applicationManager = applicationManager;
            _authorizationManager = authorizationManager;
            _scopeManager = scopeManager;
            _signInManager = signInManager;
            _userManager = userManager;
            _roleManager = roleManager;
            _configuration = configuration;
            _sharedLocalizer = sharedLocalizer;
            _claimprefixval = _configuration[nameof(OidcAllowedScope) + ":" + nameof(OidcAllowedScope.ClaimPrefix)];
            if (string.IsNullOrEmpty(_claimprefixval)) _claimprefixval = OidcAllowedScope.ClaimPrefix + "."; else _claimprefixval += ".";
            _roleprefixval = _configuration[nameof(OidcAllowedScope) + ":" + nameof(OidcAllowedScope.RolePrefix)];
            if (string.IsNullOrEmpty(_roleprefixval)) _roleprefixval = OidcAllowedScope.RolePrefix + "."; else _roleprefixval += ".";
        }

        #region Authorization code, implicit and hybrid flows
        // Note: to support interactive flows like the code flow,
        // you must provide your own authorization endpoint action:

        [HttpGet("~/connect/authorize")]
        [HttpPost("~/connect/authorize")]
        [IgnoreAntiforgeryToken]
        public async Task<IActionResult> Authorize()
        {
            var request = HttpContext.GetOpenIddictServerRequest() ??
                throw new InvalidOperationException(_sharedLocalizer["The OpenID Connect request cannot be retrieved."]);

            // Try to retrieve the user principal stored in the authentication cookie and redirect
            // the user agent to the login page (or to an external provider) in the following cases:
            //
            //  - If the user principal can't be extracted or the cookie is too old.
            //  - If prompt=login was specified by the client application.
            //  - If a max_age parameter was provided and the authentication cookie is not considered "fresh" enough.
            var result = await HttpContext.AuthenticateAsync(IdentityConstants.ApplicationScheme);
            if (result == null || !result.Succeeded || request.HasPrompt(Prompts.Login) ||
               (request.MaxAge != null && result.Properties?.IssuedUtc != null &&
                DateTimeOffset.UtcNow - result.Properties.IssuedUtc > TimeSpan.FromSeconds(request.MaxAge.Value)))
            {
                // If the client application requested promptless authentication,
                // return an error indicating that the user is not logged in.
                if (request.HasPrompt(Prompts.None))
                {
                    return Forbid(
                        authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                        properties: new AuthenticationProperties(new Dictionary<string, string?>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.LoginRequired,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = _sharedLocalizer["The user is not logged in."]
                        }));
                }

                // To avoid endless login -> authorization redirects, the prompt=login flag
                // is removed from the authorization request payload before redirecting the user.
                var prompt = string.Join(" ", request.GetPrompts().Remove(Prompts.Login));

                var parameters = Request.HasFormContentType ?
                    Request.Form.Where(parameter => parameter.Key != Parameters.Prompt).ToList() :
                    Request.Query.Where(parameter => parameter.Key != Parameters.Prompt).ToList();

                parameters.Add(KeyValuePair.Create(Parameters.Prompt, new StringValues(prompt)));

                return Challenge(
                    authenticationSchemes: IdentityConstants.ApplicationScheme,
                    properties: new AuthenticationProperties
                    {
                        RedirectUri = Request.PathBase + Request.Path + QueryString.Create(parameters)
                    });
            }

            // Retrieve the profile of the logged in user.
            var user = await _userManager.GetUserAsync(result.Principal) ??
                throw new InvalidOperationException(_sharedLocalizer["The user details cannot be retrieved."]);

            string clientId = request.ClientId ?? "";
            // Retrieve the application details from the database.
            var application = await _applicationManager.FindByClientIdAsync(clientId) ??
                throw new InvalidOperationException(_sharedLocalizer["Details concerning the calling client application cannot be found."]);
            var pscopes = request.GetScopes().Intersect(await GetAppScopePermissions(application)).ToImmutableArray();
            // Retrieve the permanent authorizations associated with the user and the calling client application.
            var authorizationsEnumerable = _authorizationManager.FindAsync(
                subject: await _userManager.GetUserIdAsync(user),
                client: clientId,
                status: Statuses.Valid,
                type: AuthorizationTypes.Permanent,
                scopes: pscopes) ??
                throw new InvalidOperationException(_sharedLocalizer["Unable to obtain Authorizations for this user and client."]);
            List<object> authorizations = new();
            await foreach (var a in authorizationsEnumerable)
            {
                authorizations.Add(a);
            }
            switch (await _applicationManager.GetConsentTypeAsync(application))
            {
                // If the consent is external (e.g when authorizations are granted by a sysadmin),
                // immediately return an error if no authorization can be found in the database.
                case ConsentTypes.External when !authorizations.Any():
                    return Forbid(
                        authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                        properties: new AuthenticationProperties(new Dictionary<string, string?>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.ConsentRequired,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                                _sharedLocalizer["The logged in user is not allowed to access this client application."]
                        }));


                // If the consent is implicit or if an authorization was found,
                // return an authorization response without displaying the consent form.
                case ConsentTypes.Implicit:
                case ConsentTypes.External when authorizations.Any():
                case ConsentTypes.Explicit when authorizations.Any() && !request.HasPrompt(Prompts.Consent):
                    // Create the claims-based identity that will be used by OpenIddict to generate tokens.
                    var identity = await PrepareWithoutConsentResponse(application, user, authorizations, pscopes);
                    return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                // At this point, no authorization was found in the database and an error must be returned
                // if the client application specified prompt=none in the authorization request.
                case ConsentTypes.Explicit when request.HasPrompt(Prompts.None):
                case ConsentTypes.Systematic when request.HasPrompt(Prompts.None):
                    return Forbid(
                        authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                        properties: new AuthenticationProperties(new Dictionary<string, string?>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.ConsentRequired,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                                _sharedLocalizer["Interactive user consent is required."]
                        }));

                // In every other case, render the consent form.
                default:
                    AuthorizeDto model = await PrepareAuthorizeDto(null, application, user, clientId, pscopes);
                    return View(model);
            }
        }

        [Authorize, MultipleSubmin("submit.Deny")]
        [HttpPost("~/connect/authorize"), ValidateAntiForgeryToken]
        // Notify OpenIddict that the authorization grant has been denied by the resource owner
        // to redirect the user agent to the client application using the appropriate response_mode.
        public IActionResult Deny() => Forbid(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);

        [Authorize, MultipleSubmin("submit.Accept")]
        [HttpPost("~/connect/authorize"), ValidateAntiForgeryToken]
        public async Task<IActionResult> Accept([Bind("ApplicationName", "PersDataToAuthorize", "RoleToAuthorize", "ScopesToAuthorize")] AuthorizeDto authorizeDto)
        {
            var request = HttpContext.GetOpenIddictServerRequest() ??
                throw new InvalidOperationException(_sharedLocalizer["The OpenID Connect request cannot be retrieved."]);

            // Retrieve the profile of the logged in user.
            var user = await _userManager.GetUserAsync(User) ??
                throw new InvalidOperationException(_sharedLocalizer["The user details cannot be retrieved."]);

            string clientId = authorizeDto.ApplicationName;
            // Retrieve the application details from the database.
            var application = await _applicationManager.FindByClientIdAsync(authorizeDto.ApplicationName) ??
                throw new InvalidOperationException(_sharedLocalizer["Details concerning the calling client application cannot be found."]);

            // collect scopes including Email, Profile, Roles
            var scopes = authorizeDto.ScopesToAuthorize.Intersect(await GetAppScopePermissions(application)).ToList();
            if (authorizeDto.PersDataToAuthorize.Contains(Claims.Email)) scopes.Add(OpenIddictConstants.Scopes.Email);
            if( authorizeDto.PersDataToAuthorize.Contains(Claims.Subject) ||
                authorizeDto.PersDataToAuthorize.Contains(Claims.Name)) scopes.Add(OpenIddictConstants.Scopes.Profile);
            if(authorizeDto.RoleToAuthorize.Count > 0) scopes.Add(OpenIddictConstants.Scopes.Roles);

            // Retrieve the permanent authorizations associated with the user and the calling client application.
            var authorizationsEnumerable = _authorizationManager.FindAsync(
                subject: await _userManager.GetUserIdAsync(user),
                client: clientId,
                status: Statuses.Valid,
                type: AuthorizationTypes.Permanent,
                scopes: scopes.ToImmutableArray()) ??
                throw new InvalidOperationException(_sharedLocalizer["Unable to obtain Authorizations for this user and client."]);
            List<object> authorizations = new();
            await foreach (var a in authorizationsEnumerable)
            {
                authorizations.Add(a);
            }

            // Note: the same check is already made in the other action but is repeated
            // here to ensure a malicious user can't abuse this POST-only endpoint and
            // force it to return a valid response without the external authorization.
            if (!authorizations.Any() && await _applicationManager.HasConsentTypeAsync(application, ConsentTypes.External))
            {
                return Forbid(
                    authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                    properties: new AuthenticationProperties(new Dictionary<string, string?>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.ConsentRequired,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            _sharedLocalizer["The logged in user is not allowed to access this client application."]
                    }));
            }
            // Create the claims-based identity that will be used by OpenIddict to generate tokens.
            var identity = await PrepareAcceptedResponce(application, authorizeDto, user, authorizations);
            return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
        }
        #endregion

        #region Logout support for interactive flows like code and implicit
        // Note: the logout action is only useful when implementing interactive
        // flows like the authorization code flow or the implicit flow.

        [HttpGet("~/connect/logout")]
        public IActionResult Logout() => View();

        [ActionName(nameof(Logout)), HttpPost("~/connect/logout"), ValidateAntiForgeryToken]
        public async Task<IActionResult> LogoutPost()
        {
            // Ask ASP.NET Core Identity to delete the local and external cookies created
            // when the user agent is redirected from the external identity provider
            // after a successful authentication flow (e.g Google or Facebook).
            await _signInManager.SignOutAsync();

            // Returning a SignOutResult will ask OpenIddict to redirect the user agent
            // to the post_logout_redirect_uri specified by the client application or to
            // the RedirectUri specified in the authentication properties if none was set.
            return SignOut(
                authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                properties: new AuthenticationProperties
                {
                    RedirectUri = "/"
                });
        }
        #endregion

        #region Device flow
        /*
                // Note: to support the device flow, you must provide your own verification endpoint action:
                [Authorize, HttpGet("~/connect/verify")]
                public async Task<IActionResult> Verify()
                {
                    var request = HttpContext.GetOpenIddictServerRequest() ??
                        throw new InvalidOperationException("The OpenID Connect request cannot be retrieved.");

                    // If the user code was not specified in the query string (e.g as part of the verification_uri_complete),
                    // render a form to ask the user to enter the user code manually (non-digit chars are automatically ignored).
                    if (string.IsNullOrEmpty(request.UserCode))
                    {
                        return View(new VerifyViewModel());
                    }

                    // Retrieve the claims principal associated with the user code.
                    var result = await HttpContext.AuthenticateAsync(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                    if (result.Succeeded)
                    {
                        // Retrieve the application details from the database using the client_id stored in the principal.
                        var application = await _applicationManager.FindByClientIdAsync(result.Principal.GetClaim(Claims.ClientId)) ??
                            throw new InvalidOperationException("Details concerning the calling client application cannot be found.");

                        // Render a form asking the user to confirm the authorization demand.
                        return View(new VerifyViewModel
                        {
                            ApplicationName = await _applicationManager.GetLocalizedDisplayNameAsync(application),
                            Scope = string.Join(" ", result.Principal.GetScopes()),
                            UserCode = request.UserCode
                        });
                    }

                    // Redisplay the form when the user code is not valid.
                    return View(new VerifyViewModel
                    {
                        Error = Errors.InvalidToken,
                        ErrorDescription = "The specified user code is not valid. Please make sure you typed it correctly."
                    });
                }

                [Authorize, MultipleSubmin("submit.Accept")]
                [HttpPost("~/connect/verify"), ValidateAntiForgeryToken]
                public async Task<IActionResult> VerifyAccept()
                {
                    // Retrieve the profile of the logged in user.
                    var user = await _userManager.GetUserAsync(User) ??
                        throw new InvalidOperationException("The user details cannot be retrieved.");

                    // Retrieve the claims principal associated with the user code.
                    var result = await HttpContext.AuthenticateAsync(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                    if (result.Succeeded)
                    {
                        // Create the claims-based identity that will be used by OpenIddict to generate tokens.
                        var identity = new ClaimsIdentity(
                            authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                            nameType: Claims.Name,
                            roleType: Claims.Role);

                        // Add the claims that will be persisted in the tokens.
                        identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user))
                                .SetClaim(Claims.Email, await _userManager.GetEmailAsync(user))
                                .SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user))
                                .SetClaims(Claims.Role, (await _userManager.GetRolesAsync(user)).ToImmutableArray());

                        await AddUserClaimsAsync(identity, user);

                        // Note: in this sample, the granted scopes match the requested scope
                        // but you may want to allow the user to uncheck specific scopes.
                        // For that, simply restrict the list of scopes before calling SetScopes.
                        identity.SetScopes(result.Principal.GetScopes());
                        identity.SetResources(await _scopeManager.ListResourcesAsync(identity.GetScopes()).ToListAsync());
                        identity.SetDestinations(GetDestinations);

                        var properties = new AuthenticationProperties
                        {
                            // This property points to the address OpenIddict will automatically
                            // redirect the user to after validating the authorization demand.
                            RedirectUri = "/pauth"
                        };

                        return SignIn(new ClaimsPrincipal(identity), properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                    }

                    // Redisplay the form when the user code is not valid.
                    return View(new VerifyViewModel
                    {
                        Error = Errors.InvalidToken,
                        ErrorDescription = "The specified user code is not valid. Please make sure you typed it correctly."
                    });
                }

                [Authorize, MultipleSubmin("submit.Deny")]
                [HttpPost("~/connect/verify"), ValidateAntiForgeryToken]
                // Notify OpenIddict that the authorization grant has been denied by the resource owner.
                public IActionResult VerifyDeny() => Forbid(
                    authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                    properties: new AuthenticationProperties()
                    {
                        // This property points to the address OpenIddict will automatically
                        // redirect the user to after rejecting the authorization demand.
                        RedirectUri = "/pauth"
                    });
        */
        #endregion

        #region Password, authorization code, device and refresh token flows
        // Note: to support non-interactive flows like password,
        // you must provide your own token endpoint action:

        [HttpPost("~/connect/token"), Produces("application/json")]
        public async Task<IActionResult> Exchange()
        {
            var request = HttpContext.GetOpenIddictServerRequest() ??
                throw new InvalidOperationException(_sharedLocalizer["The OpenID Connect request cannot be retrieved."]);

            if (request.IsPasswordGrantType())
            {
                var user = await _userManager.FindByNameAsync(request.Username);
                if (user is null)
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string?>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                           _sharedLocalizer["The username/password couple is invalid."]
                    });

                    return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                // Validate the username/password parameters and ensure the account is not locked out.
                var result = await _signInManager.CheckPasswordSignInAsync(user, request.Password, lockoutOnFailure: true);
                if (!result.Succeeded)
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string?>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                          _sharedLocalizer["The username/password couple is invalid."]
                    });

                    return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                // Create the claims-based identity that will be used by OpenIddict to generate tokens.
                var identity = new ClaimsIdentity(
                    authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                    nameType: Claims.Name,
                    roleType: Claims.Role);

                // Add the claims that will be persisted in the tokens.
                identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user))
                        .SetClaim(Claims.Email, await _userManager.GetEmailAsync(user))
                        .SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user))
                        .SetClaims(Claims.Role, (await _userManager.GetRolesAsync(user)).ToImmutableArray());

                await AddUserClaimsAsync(identity, user);

                // Set the list of scopes granted to the client application.
                identity.SetScopes(new[]
                {
                    OpenIddictConstants.Scopes.OpenId,
                    OpenIddictConstants.Scopes.Email,
                    OpenIddictConstants.Scopes.Profile,
                    OpenIddictConstants.Scopes.Roles
                }.Intersect(request.GetScopes()));

                identity.SetDestinations(GetDestinations);

                return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
            }
            else if (request.IsAuthorizationCodeGrantType() || request.IsDeviceCodeGrantType() || request.IsRefreshTokenGrantType())
            {
                // Retrieve the claims principal stored in the authorization code/refresh token.
                var result = await HttpContext.AuthenticateAsync(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);

                // Retrieve the user profile corresponding to the authorization code/refresh token.
                var user = await _userManager.FindByIdAsync(result.Principal?.GetClaim(Claims.Subject) ?? "");
                if (user is null)
                {
                    return Forbid(
                        authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                        properties: new AuthenticationProperties(new Dictionary<string, string?>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidGrant,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = _sharedLocalizer["The token is no longer valid."]
                        }));
                }

                // Ensure the user is still allowed to sign in.
                if (!await _signInManager.CanSignInAsync(user))
                {
                    return Forbid(
                        authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme,
                        properties: new AuthenticationProperties(new Dictionary<string, string?>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidGrant,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = _sharedLocalizer["The user is no longer allowed to sign in."]
                        }));
                }

                var identity = new ClaimsIdentity(result.Principal?.Claims,
                    authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                    nameType: Claims.Name,
                    roleType: Claims.Role);

                // Override the user claims present in the principal in case they
                // changed since the authorization code/refresh token was issued.
                identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user))
                        .SetClaim(Claims.Email, await _userManager.GetEmailAsync(user))
                        .SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user))
                        .SetClaims(Claims.Role, (await _userManager.GetRolesAsync(user)).ToImmutableArray());

                await AddUserClaimsAsync(identity, user);

                identity.SetDestinations(GetDestinations);

                // Returning a SignInResult will ask OpenIddict to issue the appropriate access/identity tokens.
                return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
            }
            else if (request.IsClientCredentialsGrantType())
            {
                // Note: the client credentials are automatically validated by OpenIddict:
                // if client_id or client_secret are invalid, this action won't be invoked.

                var application = await _applicationManager.FindByClientIdAsync(request.ClientId ?? "") ?? 
                    throw new InvalidOperationException(_sharedLocalizer["The application details cannot be found in the database."]);

                // Create the claims-based identity that will be used by OpenIddict to generate tokens.
                var identity = new ClaimsIdentity(
                    authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                    nameType: Claims.Name,
                    roleType: Claims.Role);

                // Add the claims that will be persisted in the tokens (use the client_id as the subject identifier).
                identity.SetClaim(Claims.Subject, await _applicationManager.GetClientIdAsync(application));
                identity.SetClaim(Claims.Name, await _applicationManager.GetDisplayNameAsync(application));

                // Note: In the original OAuth 2.0 specification, the client credentials grant
                // doesn't return an identity token, which is an OpenID Connect concept.
                //
                // As a non-standardized extension, OpenIddict allows returning an id_token
                // to convey information about the client application when the "openid" scope
                // is granted (i.e specified when calling principal.SetScopes()). When the "openid"
                // scope is not explicitly set, no identity token is returned to the client application.

                var gscopes = request.GetScopes().Intersect(await GetAppScopePermissions(application));
                // Set the list of scopes granted to the client application in access_token.
                if ((gscopes != null) && gscopes.Any()) {
                    identity.SetScopes(gscopes);
                    var lrs = _scopeManager.ListResourcesAsync(identity.GetScopes());
                    List<string> rsrs = new();
                    await foreach (var r in lrs)
                    {
                        rsrs.Add(r);
                    }
                    identity.SetResources(rsrs);
                }
                identity.SetDestinations(GetDestinations);
                return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
            }

            throw new InvalidOperationException("The specified grant type is not supported.");
        }
        #endregion


        #region Helper methods
        // PrepareWithoutConsentResponse is logically correct
        protected virtual async Task<ClaimsIdentity> PrepareWithoutConsentResponse(object application, OidcIdentityUser user, List<object> authorizations, ImmutableArray<string> permissionedScopes)
        {
            string clientId = await _applicationManager.GetIdAsync(application) ??
                throw new InvalidOperationException(_sharedLocalizer["Details concerning the ID of the calling client application cannot be found."]);
            // Create the claims-based identity that will be used by OpenIddict to generate tokens.
            var identity = new ClaimsIdentity(
                authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                nameType: Claims.Name,
                roleType: Claims.Role);
            if (permissionedScopes.Contains(OpenIddictConstants.Scopes.Email))
                identity.SetClaim(Claims.Email, await _userManager.GetEmailAsync(user));

            if (permissionedScopes.Contains(OpenIddictConstants.Scopes.Profile))
            {
                identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user));
                identity.SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user));
            }
            if (permissionedScopes.Contains(OpenIddictConstants.Scopes.Roles))
            {
                var rls = await GetUserRolesAsync(user);
                if (rls.Count > 0)
                {
                    identity.SetClaims(Claims.Role, rls.ToImmutableArray());
                }
            }
            await AddUserClaimsAsync(identity, user);

            // permissionedScopes include (Email, Profile, Roles)
            if (permissionedScopes.Length > 0)
            {
                identity.SetScopes(permissionedScopes);
                var lrs = _scopeManager.ListResourcesAsync(identity.GetScopes());
                List<string> rsrs = new();
                await foreach (var r in lrs)
                {
                    rsrs.Add(r);
                }
                identity.SetResources(rsrs.ToImmutableArray());
            }
            // Automatically create a permanent authorization to avoid requiring explicit consent
            // for future authorization or token requests containing the same scopes.
            var authorization = authorizations.LastOrDefault();
            authorization ??= await _authorizationManager.CreateAsync(
                identity: identity,
                subject: await _userManager.GetUserIdAsync(user),
                client: clientId,
                type: AuthorizationTypes.Permanent,
                scopes: identity.GetScopes());

            identity.SetAuthorizationId(await _authorizationManager.GetIdAsync(authorization));
            identity.SetDestinations(GetDestinations);
            return identity;
        }
        // AuthorizeDto.PersDataToAuthorize can contain (Email, Profile)
        // AuthorizeDto.RoleToAuthorize can contain (Role)
        protected virtual async Task<ClaimsIdentity> PrepareAcceptedResponce(object application, AuthorizeDto authorizeDto, OidcIdentityUser user, List<object> authorizations)
        {
            // Create the claims-based identity that will be used by OpenIddict to generate tokens.
            var identity = new ClaimsIdentity(
                authenticationType: TokenValidationParameters.DefaultAuthenticationType,
                nameType: Claims.Name,
                roleType: Claims.Role);
            // get application permissions
            List<string> permissions = await GetAppScopePermissions(application);
            // set claims
            bool HasEmailScope = permissions.Contains(OpenIddictConstants.Scopes.Email) &&
                authorizeDto.PersDataToAuthorize.Contains(Claims.Email);
            if (HasEmailScope) { 
                identity.SetClaim(Claims.Email, await _userManager.GetEmailAsync(user));
            }
            bool HasProfileScope = false;
            if (permissions.Contains(OpenIddictConstants.Scopes.Profile))
            {
                if (authorizeDto.PersDataToAuthorize.Contains(Claims.Subject))
                {
                    identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user));
                    HasProfileScope = true;
                }
                if (authorizeDto.PersDataToAuthorize.Contains(Claims.Name))
                {
                    identity.SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user));
                    HasProfileScope = true;
                }
            }
            // role scope added
            bool HasRoleScope = false;
            if (permissions.Contains(OpenIddictConstants.Scopes.Roles))
            {
                HasRoleScope = true;
                var rls = await GetUserRolesAsync(user);
                if (rls.Count > 0)
                {
                    for (int i = rls.Count - 1; i >= 0; i--)
                    {
                        if (!authorizeDto.RoleToAuthorize.Contains(rls[i]))
                        {
                            rls.RemoveAt(i);
                        }
                    }
                    if (rls.Count > 0)
                        identity.SetClaims(Claims.Role, rls.ToImmutableArray());
                    else
                        HasRoleScope = false;
                }
            }
            // PersDataToAuthorize gives the scopes
            // RoleToAuthorize gives the scopes
            // ScopesToAuthorize gives the scopes
            await AddUserClaimsAsync(identity, user);

            // Scopes and Resources.
            if (authorizeDto.ScopesToAuthorize.Count > 0)
            {
                // set the scopes
                 
                var lrs = _scopeManager.ListResourcesAsync(authorizeDto.ScopesToAuthorize.ToImmutableArray());
                List<string> rsrs = new();
                await foreach (var r in lrs)
                {
                    rsrs.Add(r);
                }
                List<string> slst = authorizeDto.ScopesToAuthorize.ToList();
                if(HasRoleScope) slst.Add(Permissions.Scopes.Roles[Prefixes.Scope.Length..]);
                if (HasProfileScope) slst.Add(Permissions.Scopes.Profile[Prefixes.Scope.Length..]);
                identity.SetScopes(slst.ToImmutableArray());
                identity.SetResources(rsrs.ToImmutableArray());
            }
            // Automatically create a permanent authorization to avoid requiring explicit consent
            // for future authorization or token requests containing the same scopes.
            var authorization = authorizations.LastOrDefault();
            authorization ??= await _authorizationManager.CreateAsync(
                identity: identity,
                subject: await _userManager.GetUserIdAsync(user),
                client: authorizeDto.ApplicationName,
                type: AuthorizationTypes.Permanent,
                scopes: identity.GetScopes());
            identity.SetAuthorizationId(await _authorizationManager.GetIdAsync(authorization));
            identity.SetDestinations(GetDestinations);
            return identity;
        }
        
        protected virtual async Task<AuthorizeDto> PrepareAuthorizeDto(AuthorizeDto? model, object application, OidcIdentityUser user, string clientId, ImmutableArray<string> pscopes)
        {
            model ??= new AuthorizeDto();

            model.ApplicationName = clientId;
            model.LocalizedApplicationName = await _applicationManager.GetLocalizedDisplayNameAsync(application);

            // personal Data
            if (pscopes.Contains(OpenIddictConstants.Scopes.Email))
                model.PersDataToAuthorize.Add(Claims.Email);
            if (pscopes.Contains(OpenIddictConstants.Scopes.Profile))
            {
                model.PersDataToAuthorize.Add(Claims.Subject);
                model.PersDataToAuthorize.Add(Claims.Name);
            }
            // roles
            if (pscopes.Contains(OpenIddictConstants.Scopes.Roles))
            {
                model.RoleToAuthorize.AddRange(await GetUserRolesAsync(user));
            }
            // collect scopes without (Email, Profile, Roles)
            List<(string, string?, string?, List<string>)> ScpWithRes = new();
            foreach (var rscp in pscopes)
            {
                if ((rscp == OpenIddictConstants.Scopes.Email) ||
                    (rscp == OpenIddictConstants.Scopes.Profile) ||
                    (rscp == OpenIddictConstants.Scopes.Roles)) continue;

                model.ScopesToAuthorize.Add(rscp);
                Object? oscp = await _scopeManager.FindByNameAsync(rscp);
                if (oscp != null)
                {
                    string? ldispname = await _scopeManager.GetLocalizedDisplayNameAsync(oscp);
                    string? ldescr = await _scopeManager.GetLocalizedDescriptionAsync(oscp);
                    (string, string?, string?, List<string>) itm = (rscp, ldispname, ldescr, new List<string>());
                    foreach (var resource in await _scopeManager.GetResourcesAsync(oscp))
                    {
                        itm.Item4.Add(resource);
                    }
                    ScpWithRes.Add(itm);
                }
            }
            ViewBag.ScpWithRes = ScpWithRes;
            return model;
        }
        /// <summary>
        /// Add claims assigned to user directly or derived from roles assigned to user to ClaimsIdentity
        /// </summary>
        /// <param name="claimsIdentity"></param>
        /// <param name="user"></param>
        /// <returns></returns>
        protected virtual async Task AddUserClaimsAsync(ClaimsIdentity claimsIdentity, OidcIdentityUser user)
        {
            foreach (var claim in await _userManager.GetClaimsAsync(user))
            {
                if (claim != null)
                {
                    if ((claim.Type != null) && claim.Type.StartsWith(_claimprefixval)) continue;
                    claimsIdentity.AddClaim(claim);
                }
            }
            foreach (var assignedRole in await _userManager.GetRolesAsync(user))
            {
                if ((assignedRole != null) && assignedRole.StartsWith(_roleprefixval)) continue;
                var role = await _roleManager.FindByNameAsync(assignedRole);
                foreach (var claim in await _roleManager.GetClaimsAsync(role))
                {
                    if (claim != null)
                    {
                        if ((claim.Type != null) && claim.Type.StartsWith(_claimprefixval)) continue;
                        claimsIdentity.AddClaim(claim);
                    }
                }
            }
        }
        protected virtual async Task<List<string>> GetUserRolesAsync(OidcIdentityUser user)
        {
            List<string> rslt = new(); 
            foreach (var assignedRole in await _userManager.GetRolesAsync(user))
            {
                if ((assignedRole != null) && (!assignedRole.StartsWith(_roleprefixval)))
                {
                        rslt.Add(assignedRole);
                }
                
            }
            return rslt;
        }
        protected virtual async Task<List<string>> GetAppScopePermissions(object app)
        {
            var permissions = await _applicationManager.GetPermissionsAsync(app);
            List<string> scopes = new();
            foreach (var permission in permissions)
            {
                if (string.IsNullOrEmpty(permission)) continue;
                if (!permission.StartsWith(Prefixes.Scope)) continue;
                var prms = permission[Prefixes.Scope.Length..].Trim().Split(Separators.Space, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                if (prms.Length > 0)
                {
                    scopes.AddRange(prms);
                }
            }
            return scopes;
        }
        protected virtual IEnumerable<string> GetDestinations(Claim claim)
        {
            // Note: by default, claims are NOT automatically included in the access and identity tokens.
            // To allow OpenIddict to serialize them, you must attach them a destination, that specifies
            // whether they should be included in access tokens, in identity tokens or in both.

            switch (claim.Type)
            {
                case Claims.Name:
                    yield return Destinations.AccessToken;

                    if (claim.Subject != null && claim.Subject.HasScope(OpenIddictConstants.Scopes.Profile))
                        yield return Destinations.IdentityToken;

                    yield break;

                case Claims.Email:
                    yield return Destinations.AccessToken;

                    if (claim.Subject != null && claim.Subject.HasScope(OpenIddictConstants.Scopes.Email))
                        yield return Destinations.IdentityToken;

                    yield break;

                case Claims.Role:
                    yield return Destinations.AccessToken;

                    if (claim.Subject != null && claim.Subject.HasScope(OpenIddictConstants.Scopes.Roles))
                        yield return Destinations.IdentityToken;

                    yield break;

                // Never include the security stamp in the access and identity tokens, as it's a secret value.
                case "AspNet.Identity.SecurityStamp":
                    yield break;

                default:

                    if (claim.Properties.ContainsKey("IncludeInAccessToken"))
                    {
                        if (bool.TryParse(claim.Properties["IncludeInAccessToken"], out bool includeInAccessToken)
                            && includeInAccessToken)
                        {
                            yield return Destinations.AccessToken;
                        }
                    }

                    if (claim.Properties.ContainsKey("IncludeInIdentityToken"))
                    {
                        if (bool.TryParse(claim.Properties["IncludeInIdentityToken"], out bool includeInIdentityToken)
                            && includeInIdentityToken)
                        {
                            yield return Destinations.IdentityToken;
                        }
                    }
                    yield break;
            }
        }
        #endregion
    }
}
